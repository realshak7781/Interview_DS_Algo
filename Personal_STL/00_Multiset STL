// VISIT MY NOTION FOR MORE SUCH TIPS: https://www.notion.so/1d226cb2bf3f80fba94ee0fc9f28bc65?v=1d226cb2bf3f81af8c52000c55f75d7a


ğŸ“ Count of Range Sum â€“ STL Concepts & Common Pitfall
âœ… Problem Recap
Given an integer array nums and two integers lower and upper, count the number of range sums (i, j) such that:

lower â‰¤ sum(nums[i..j]) â‰¤ upper

ğŸ§° Key STL Concepts Used
1. std::multiset
â€¢ âœ… Stores elements in sorted order.
â€¢ âœ… Allows duplicate elements.
â€¢ âœ… Provides efficient O(log n) operations for insertions and range queries.
â€¢ ğŸ¯ Use Case Here: Storing prefix sums to efficiently count valid ranges.
2. insert(val)
â€¢ Inserts value in the multiset while maintaining sorted order.

prefixSet.insert(curSum);

3. lower_bound(val)
â€¢ Returns iterator to first element â‰¥ val
â€¢ Used to include the lower bound of the target range.
4. upper_bound(val)
â€¢ Returns iterator to first element > val
â€¢ Used to exclude the upper bound.

auto it1 = prefixSet.lower_bound(curSum - upper);
auto it2 = prefixSet.upper_bound(curSum - lower);

5. std::distance(it1, it2)
â€¢ Returns the number of elements between two iterators.
â€¢ ğŸš¨ BUG: You did std::distance(it2, it1) in the wrong order:

count += std::distance(it1, it2);  // âŒ wrong
count += std::distance(it2, it1);  // âœ… correct

Because it2 is the start of range and it1 is the end â€” order matters!
â—ï¸Common Mistake (Bug Recap)
â€¢ âŒ Reversed iterators in std::distance(it1, it2) gave incorrect count, possibly negative.
â€¢ âœ… Fix: Always use std::distance(start, end) where start <= end.
ğŸ“Œ Final Code Snippet (Corrected)

auto it1 = prefixSet.lower_bound(curSum - upper);
auto it2 = prefixSet.upper_bound(curSum - lower);
count += std::distance(it1, it2);  // âœ… Correct order

